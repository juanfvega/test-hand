import * as THREE from 'three';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import gsap from 'gsap';
import './style.css';

// 1. VISOR 3D (HERO SECTION)
// ==========================================

const canvasContainer = document.getElementById('canvas-container');
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x270315); // --illusion-950

// 2. Camera
const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(-7.58, 8.49, 27.06);
scene.add(camera);

// 3. Renderer
const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
canvasContainer.appendChild(renderer.domElement);

// Controls
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.enableZoom = false;
controls.enablePan = true;

// ==========================================
// DEBUG UI: Camera Info & Zoom
// ==========================================
const debugUI = document.createElement('div');
debugUI.style.position = 'absolute';
debugUI.style.top = '10px';
debugUI.style.left = '10px';
debugUI.style.color = 'lime';
debugUI.style.backgroundColor = 'rgba(0,0,0,0.5)';
debugUI.style.padding = '5px 10px';
debugUI.style.fontFamily = 'monospace';
debugUI.style.fontSize = '12px';
debugUI.style.pointerEvents = 'none';
debugUI.style.zIndex = '1000';
document.body.appendChild(debugUI);

function updateDebugInfo() {
  const distance = camera.position.distanceTo(controls.target);
  debugUI.innerHTML = `
        <strong>Camera Debug</strong><br>
        x: ${camera.position.x.toFixed(2)}<br>
        y: ${camera.position.y.toFixed(2)}<br>
        z: ${camera.position.z.toFixed(2)}<br>
        Zoom (Dist): ${distance.toFixed(2)}
    `;
}

controls.addEventListener('change', updateDebugInfo);
updateDebugInfo();

// Lights
const ambientLight = new THREE.AmbientLight(0xffffff, 2);
scene.add(ambientLight);

const dirLight = new THREE.DirectionalLight(0xffffff, 3);
dirLight.position.set(5, 5, 5);
scene.add(dirLight);

// Model
let nailsMesh = null;
let modelGroup = null;

// Placeholder Function
function createPlaceholderHand() {
  const group = new THREE.Group();
  const fingerGeo = new THREE.CapsuleGeometry(0.5, 3, 4, 8);
  const material = new THREE.MeshStandardMaterial({ color: 0xffccaa });

  for (let i = 0; i < 5; i++) {
    const finger = new THREE.Mesh(fingerGeo, material);
    finger.position.x = (i - 2) * 1.5;
    finger.position.y = Math.sin(i) * 0.5;

    // Add nail
    const nailGeo = new THREE.CapsuleGeometry(0.4, 0.5, 4, 8);
    const nailMat = new THREE.MeshStandardMaterial({ color: 0xe43493 });
    const nail = new THREE.Mesh(nailGeo, nailMat);
    nail.position.y = 1.6;
    nail.position.z = 0.3;
    nail.scale.set(1, 0.5, 0.2);
    nail.name = `Nail_${i}`;

    finger.add(nail);
    group.add(finger);

    if (i === 2) nailsMesh = nail; // Assign one nail for color picker logic
  }
  return group;
}

const mtlLoader = new MTLLoader();
mtlLoader.load('/Hand.mtl', (materials) => {
  materials.preload();

  const objLoader = new OBJLoader();
  objLoader.setMaterials(materials);
  objLoader.load('/Hand.obj', (object) => {
    modelGroup = object;
    scene.add(modelGroup);

    modelGroup.position.set(5, -1, 0);
    modelGroup.rotation.y = -Math.PI / 2;
    modelGroup.scale.set(3, 3, 3);

    modelGroup.traverse((child) => {
      if (child.isMesh) {
        // Create a high-quality material foundation
        const baseMaterialProps = {
          metalness: 0,
          roughness: 0.5,
        };

        const name = child.name.toLowerCase();
        const parentName = child.parent ? child.parent.name.toLowerCase() : '';

        if (name.includes('nails') || parentName.includes('nails')) {
          nailsMesh = child;
          // Use a specific material for nails to allow color changing
          nailsMesh.material = new THREE.MeshStandardMaterial({
            ...baseMaterialProps,
            color: 0xe43493, // Initial pink color
            roughness: 0.1,   // Shinier for nails
            metalness: 0.3
          });
        } else if (name.includes('hands') || name.includes('hand') || parentName.includes('hands') || parentName.includes('hand')) {
          // Apply skin color
          child.material = new THREE.MeshStandardMaterial({
            ...baseMaterialProps,
            color: 0xffccaa, // Skin tone
            roughness: 0.6
          });
        }
      }
    });

    console.log("Modelo Hand.obj cargado correctamente.");

  }, undefined, (error) => {
    console.warn("Error cargando Hand.obj", error);
    // Fallback to placeholder if OBJ fails
    modelGroup = createPlaceholderHand();
    scene.add(modelGroup);
    modelGroup.position.set(5, 0, 0);
    modelGroup.scale.set(2, 2, 2);
    modelGroup.rotation.y = -Math.PI / 2;
  });
}, undefined, (error) => {
  console.warn("Error cargando Hand.mtl", error);
  // Try loading OBJ without materials if MTL fails
  const objLoader = new OBJLoader();
  objLoader.load('/Hand.obj', (object) => {
    modelGroup = object;
    scene.add(modelGroup);
    // ... same setup ...
    modelGroup.position.set(5, -1, 0);
    modelGroup.rotation.y = -Math.PI / 2;
    modelGroup.scale.set(3, 3, 3);
    // Traversing to find nails... 
    modelGroup.traverse((child) => {
      if (child.isMesh && child.name.toLowerCase().includes('nails')) {
        nailsMesh = child;
        nailsMesh.material = new THREE.MeshStandardMaterial({ color: 0xe43493 });
      }
    });
  }, undefined, (err) => {
    console.warn("Error cargando Hand.obj (sin MTL)", err);
    modelGroup = createPlaceholderHand();
    scene.add(modelGroup);
  });
});

// Color Picker Logic
// Color Picker Logic
const colorPicker = document.getElementById('colorPicker');
if (colorPicker) {
  colorPicker.addEventListener('input', (e) => {
    const color = e.target.value;

    // Strategy: Traverse the modelGroup and update anything identifying as a nail.
    // This covers both the placeholder (multiple Nail_x meshes) and the imported OBJ (Nails mesh).
    if (modelGroup) {
      modelGroup.traverse((child) => {
        if (child.isMesh) {
          const name = child.name.toLowerCase();
          const parentName = child.parent ? child.parent.name.toLowerCase() : '';

          if (name.includes('nail') || parentName.includes('nail')) {
            // Determine if we need to update a single material or an array
            if (Array.isArray(child.material)) {
              child.material.forEach(m => m.color.set(color));
            } else {
              child.material.color.set(color);
            }
          }
        }
      });
    }
  });
}

// Animation
function animate() {
  requestAnimationFrame(animate);
  controls.update();

  if (modelGroup) {
    modelGroup.rotation.y = -Math.PI / 2 + Math.sin(Date.now() * 0.0005) * 0.2;
    modelGroup.position.y = -1 + Math.sin(Date.now() * 0.0005) * 0.02;
  }

  renderer.render(scene, camera);
}
animate();

// Resize
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);

  if (modelGroup) {
    if (window.innerWidth < 768) {
      modelGroup.position.set(0, -3, 0);
      modelGroup.scale.set(2.5, 2.5, 2.5);
    } else {
      modelGroup.position.set(2, -2, 0);
      modelGroup.scale.set(3, 3, 3);
    }
  }
});


// ==========================================
// GSAP CAROUSEL (Services / Transformations)
// ==========================================
// AnimaciÃ³n simple de entrada para las cards

const cards = document.querySelectorAll('.card');
if (cards.length > 0) {
  gsap.from(cards, {
    duration: 1,
    y: 100,
    opacity: 0,
    stagger: 0.2,
    ease: "power3.out",
    scrollTrigger: {
      trigger: ".service-grid",
      start: "top 80%",
    }
  });
}
